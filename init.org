#+TITLE: Emacs configuration file
#+AUTHOR: Matthias Schmitt
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

This is my emacs configuration file in literate style as an org mode file.

* Preface

We automatically reload the configuration after changes to the 'init.org' file.

* Tangle

TODO why are there use-package errors when using byte-compile-file

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
    tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name "init.org" user-emacs-directory))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	;; (byte-compile-file (expand-file-name "init.el" user-emacs-directory))
	)))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* Initial Stuff

Disabling GC (by setting `gc-cons-threshold' to a very large value)
during startup is said to improve startup time
by reducing the number of GC runs.

#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory "~/.emacs.d.old/")

  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  ;; (add-hook 'after-init-hook (lambda ()
  ;; 			     (setq gc-cons-threshold radian--orig-gc-cons-threshold)))
#+END_SRC

Turn off mouse interface early in startup to avoid momentary display.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC

straight.el 

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")

  ;; Bootstrap straight.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))




  ;; Package `use-package' provides a handy macro by the same name which
  ;; is essentially a wrapper around `with-eval-after-load' with a lot
  ;; of handy syntactic sugar and useful features.
  (eval-when-compile 
    (straight-use-package 'use-package))

  ;; Tell `use-package' to always load features lazily unless told
  ;; otherwise. It's nicer to have this kind of thing be deterministic:
  ;; if `:demand' is present, the loading is eager; otherwise, the
  ;; loading is lazy. See
  ;; https://github.com/jwiegley/use-package#notes-about-lazy-loading.
  (setq use-package-always-defer t)

  ;; When configuring a feature with `use-package', also tell
  ;; straight.el to install a package of the same name, unless otherwise
  ;; specified using the `:straight' keyword.
  (setq straight-use-package-by-default t)

  (setq use-package-compute-statistics t)
  (setq use-package-verbose t)

  (load-theme 'wombat t)

  (setq custom-file (expand-file-name "emacs-custom.el" user-emacs-directory))

  (load custom-file)

#+END_SRC

* Basic packages

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :demand)

  (use-package general
    :demand
    :config (progn
	      (general-evil-setup t)
	      (defconst my-menu-key "SPC")
	      (defconst my-non-normal-menu-key "M-SPC")
	      (defconst my-leader-key ",")
	      (defconst my-non-normal-leader-key "M-,")

	      (general-create-definer my-menu-def
		:states '(normal insert emacs)
		:prefix my-menu-key
		:non-normal-prefix my-non-normal-menu-key)

	      (general-define-key
	       :keymaps 'dired-mode-map
	       "SPC" nil)

	      (my-menu-def
	       "?" 'general-describe-keybindings))

    (general-create-definer my-leader-def
      :states '(normal)
      :prefix my-leader-key
      :non-normal-prefix my-non-normal-leader-key)
    )

  (use-package which-key
    :demand
    :diminish which-key-mode
    :config (progn
	      (which-key-mode)))

  (use-package epkg
    :defer t
    ;; on func epkg-list-packages)
    )

#+END_SRC

* abo-abo

[[http://oremacs.com/swiper/][ivy & swiper manual]]

#+BEGIN_SRC emacs-lisp

    ;;; abo-abo goodness

  (my-menu-def
   "TAB" '(mode-line-other-buffer :which-key "last-buffer")
   "M-TAB" '((lambda () (interactive (switch-to-buffer-other-window (other-buffer))))
	     :which-key "last-buffer-other-window")

   "B" '(:ignore t :which-key "Buffer")
   "B m" '((lambda () (interactive (switch-to-buffer "*Messages*")))
	   :which-key "messages")
   "B M" '((lambda () (interactive (switch-to-buffer-other-window "*Messages*")))
	   :which-key "messages-in-other")
   "B s" '((lambda () (interactive (switch-to-buffer "*scratch*")))
	   :which-key "scratch")
   "B S" '((lambda () (interactive (switch-to-buffer-other-window "*scratch*")))
	   :which-key "scratch-in-other")
   "B d" 'evil-delete-buffer
   "B q" 'quit-window

   "w" 'other-window
   "W" '(:ignore t :which-key "Window")
   "W d" 'delete-window)

  (use-package ivy
    :demand
    :diminish ivy-mode
    :general (my-menu-def
		      "b" '(:ignore t :which-key "Buffer")
		      "b" (general-key-dispatch 'ivy-switch-buffer
				:timeout .33
				"m" (lambda () (interactive (switch-to-buffer "*Messages*")))
				"s" (lambda () (interactive (switch-to-buffer "*scratch*")))
				"b" 'ivy-switch-buffer
				"d" 'evil-delete-buffer
				"q" 'quit-window
				))

		      (:keymaps 'ivy-minibuffer-map
			  "C-l" 'ivy-alt-done
			  "C-h" 'ivy-backward-delete-char
			  ;;"C-SPC" 'ivy-avy
			  )

    :config (progn
	      (ivy-mode 1)
	      (setq ivy-use-virtual-buffers t)
	      (setq ivy-count-format "(%d/%d) ")
	      (setq enable-recursive-minibuffers t)
	      (setq ivy-wrap t)))

  (use-package prescient
    :demand
    :after ivy)

  (use-package ivy-prescient
    :demand
    :after prescient
    :config (progn
	      (ivy-prescient-mode t)))

  (use-package ivy-rich
    :demand
    :after (ivy counsel)
    :config (progn
	      (ivy-rich-mode 1)))

  (use-package counsel
    :demand
    :diminish counsel-mode
    :general (my-menu-def
		      "f" '(:ignore t :which-key "File")
		      "f" 'counsel-find-file
		      "F" '(:ignore t :which-key "File")
		      "F r" '(counsel-recentf :which-key "recent")
		      "r" '(counsel-recentf :which-key "recent")
		      "SPC" '(counsel-M-x :which-key "M-x"))

    :config (progn
	      (counsel-mode)))

  (use-package counsel-tramp
    :defer 15
    :after counsel
    :general (my-menu-def
		      "F t" 'counsle-tramp))

  (use-package swiper
    :defer 5
    :general (my-menu-def
		       "/" 'swiper)
    :config (setq tramp-default-method "ssh"))

  (use-package avy
    :defer 5)

  (use-package hydra
    :defer 5)
#+END_SRC

* Evil

https://github.com/emacs-evil/evil-collection

https://github.com/noctuid/evil-guide

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand
    :diminish undo-tree-mode
    :general (:states 'normal
		      "U" 'undo-tree-visualize)
    :config (progn
	      (global-undo-tree-mode +1)))

  (use-package evil
    :demand
    :init (progn
	    (setq evil-want-C-w-delete nil)
	    (setq evil-want-C-w-in-emacs-state t)
	    (evil-mode 1)
	    (cl-loop for map in '(helpful-mode-map
				   )
		    do (evil-make-overriding-map map))
	    )
    :config (progn
	      (cl-loop for (mode . state) in '((haskell-interactive-mode . emacs)
					       (haskell-error-mode . emacs)
					       (term-mode . emacs)
					       (messages-mode . motion)
					       (helpful-mode . motion)
					       (compilation-mode . motion)
					       )
		       do (evil-set-initial-state mode state))
	      ))

  (use-package evil-commentary
    :demand
    :diminish (evil-commentary-mode)
    :config (evil-commentary-mode))

  (use-package evil-surround
    :demand
    :config (global-evil-surround-mode 1))

  (use-package smartparens
    :demand
    :config (progn
	      (add-hook 'smartparens-enabled-hook #'evil-smartparens-mode)))

  (use-package evil-smartparens
    :demand
    :after (evil smartparens))

  (use-package evil-mc
    :demand
    :diminish emc
    :config (progn (global-evil-mc-mode 1)
		   (add-hook 'magit-mode-hook #'evil-mc-mode -1)))
#+END_SRC

* Project management

TODO [[https://github.com/technomancy/find-file-in-project][find-file-in-project]] vs projectile

#+BEGIN_SRC emacs-lisp

  (use-package projectile
    ;; :demand
    :general (my-menu-def
		      "p" 'projectile-find-file
		      "P" 'projectile-switch-project)
    :config (progn
	      (projectile-mode +1)
	      (setq projectile-completion-system 'ivy)
	      (setq projectile-generic-command "fd -H --ignore-file .projectile -t f -0")
	      ;; (setq projectile-indexing-method 'turbo-alien) 
	      (setq projectile-project-search-path '("~/proj/"))))

  (use-package counsel-projectile
    ;; :demand
    :after (counsel projectile)
    :general (my-menu-def
		      "p" 'counsel-projectile
		      "P" 'counsel-projectile-switch-project
		      "/" 'counsel-projectile-rg)
    :config (progn
	      (counsel-projectile-mode)))
#+END_SRC

* Org

#+BEGIN_SRC emacs-lisp
  (use-package org
    :defer 60)

  (use-package evil-org
    :demand
    :after (evil org))
#+END_SRC

* Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer 30
    :general (my-menu-def
		      "g s" 'magit-status))

  (use-package evil-magit
    :demand
    :after (evil magit))
#+END_SRC

* Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :defer 15
    :diminish yas-minor-mode
    :config (yas-global-mode 1))

  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  (use-package auto-yasnippet
    :after yasnippet
    :config (setq aya-case-fold t))
#+END_SRC

* Completion

https://company-mode.github.io/

https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html

#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 30)

  (use-package company-prescient
    :after (company))

  (use-package pos-tip
    :defer 30)

  (use-package company-quickhelp
    :after (company pos-tip)
    :config (company-quickhelp-mode))

  (use-package flycheck
    :defer 30
    :general (my-menu-def
               "e" '(:ignore t :which-key "Errors")
	       "e e" 'flycheck-buffer
	       "e b" 'flycheck-buffer
	       "e c" 'flycheck-compile
	       "e n" 'flycheck-next-error
	       "e p" 'flycheck-prev-error))

#+END_SRC

* Spelling

#+BEGIN_SRC emacs-lisp
  (cond
   ((executable-find "aspell")
    ;; you may also need `ispell-extra-args'
    (setq ispell-program-name "aspell")
    (setq-default ispell-local-dictionary "de_DE")
    ;; (setq-default ispell-local-dictionary "en_US")
    ;; (setq ispell-local-dictionary "en_US" "de_DE")
    (setq ispell-local-dictionary "de_DE")
    (setq ispell-list-command "--list"))
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")

    ;; Please note that `ispell-local-dictionary` itself will be passed to hunspell cli with "-d"
    ;; it's also used as the key to lookup ispell-local-dictionary-alist
    ;; if we use different dictionary
    (setq-default ispell-local-dictionary "en_US")
    (setq ispell-local-dictionary-alist
	  '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8))))
   (t (setq ispell-program-name nil)))


  (use-package flyspell
    :config (progn
	      ;; ommit error messages on spell checking for performance sake
	      (setq flyspell-issue-message-flag nil)))
#+END_SRC

* Programming languages
** Haskell
https://commercialhaskell.github.io/intero/

#+BEGIN_SRC emacs-lisp

;; (use-package haskell-mode
;;   :defer t
;;   :bind (:map haskell-mode-map
;; 	      ("C-c C-c" . haskell-compile))
;;   )

(use-package intero
  :hook (haskell-mode . intero-mode)
  )
    

;; (use-package haskell-process
;;   :after haskell-mode)

;; (use-package haskell-interactive-mode
;;   :after haskell-mode
;;   :contig (add-hook 'haskell-mode-hook 'interactive-haskell-mode))


#+END_SRC

** Latex

#+BEGIN_SRC emacs-lisp

;;(use-package auctex
  ;;:defer t
  ;;:hook (latex-mode)
  ;;:config (progn
	    ;;(setq TeX-parse-self t) ;; enable parse on load
	    ;;(setq TeX-auto-safe t) ;; enable parse on safe
	    ;;(setq TeX-safe-query nil)
	    ;;(setq-default TeX-master nil)
	    ;;(setq TeX-PDF-mode t)
	    ;;(add-hook 'TeX-mode-hook 'flyspell-mode)
	    ;;(if (executable-find "latexmk")
		;;)))
;;
;;(use-package auctex-latexmk
  ;;:after (auctex)
  ;;:config (progn
	    ;;(auctex-latexmk-setup)
	    ;;(setq auctex-latexmk-inherit-TeX-PDF-mode t)))

;; (use-package latex-preview-pane
;;   :defer t)

#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :hook (rust-mode))

  (use-package rustfmt
    :after (rust-mode))
#+END_SRC

* Misc
** Help

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :defer 5
    :general (my-menu-def
		      "h" '(helpful-at-point :which-key "help")
		      "H" '(:ignore t :which-key "Help")
		      "H v" 'helpful-variable
		      "H f" 'helpful-function
		      )
    :config (progn
	      (general-define-key
	       :keymaps 'helpful-mode-map
	       "q" 'quit-window)))
#+END_SRC

** Backup

#+BEGIN_SRC emacs-lisp

  (defvar --backup-directory (expand-file-name "tmp/backup" user-emacs-directory))
  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t
	backup-by-copying t
	version-control t
	delete-old-versions t)

#+END_SRC

** Indent

#+BEGIN_SRC emacs-lisp
  (use-package clean-aindent-mode
    :config (progn
	      (setq clean-aindent-is-simple-indent t)))
#+END_SRC

* Functions

#+BEGIN_SRC emacs-lisp
  (defun rename-current-file ()
    "Renames both current buffer and file it's visiting a file."
    (interactive
     (progn
       (if (not (buffer-file-name))
	   (error "Buffer '%s' is not visiting a file!" (buffer-name)))
       (let ((new-file-name (read-file-name "Rename current file to: " (file-name-directory buffer-file-name)))
	     )
	 (message "Current file renamed to %s." new-file-name)
	 (rename-file buffer-file-name new-file-name)
	 (rename-buffer new-file-name)
	 (set-visited-file-name new-file-name)
	 (set-buffer-modified-p nil)
	 (setq default-directory (file-name-directory new-file-name))
	 ))))


  ;; alternative command version
  (defun my-norm@q ()
    "Apply macro in q register on selected lines."
    (interactive)
    (evil-ex-normal (region-beginning) (region-end) "@q"))

(defun reload-dir-locals-for-current-buffer ()
  "reload dir locals for the current buffer"
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

  ;; (general-define-key
  ;;  :states '(visual global)
  ;;  "Q" 'my-norm@q)

#+END_SRC

* End
The End
